/**
 * @file test_{{ module.name }}.cpp
 * @brief Unit tests for {{ module.name }} module using Google Test framework
 * @author {{ config.author or 'Generated by C/C++ Code Generator' }}
 * @version {{ config.version }}
 * @date {{ config.generated_at[:10] }}
 */

#include <gtest/gtest.h>
#include "{{ module.name }}.h"

#include <memory>
#include <string>
#include <vector>
#include <stdexcept>

{% if config.namespace %}
using namespace {{ config.namespace }};
{% endif %}

/* ========================================================================== */
/* Test Fixture Class                                                        */
/* ========================================================================== */

class {{ module.name | pascal_case }}Test : public ::testing::Test {
protected:
    void SetUp() override {
        /* This method is called before each test */
        try {
            instance_ = std::make_unique<{{ module.name | pascal_case }}>();
        } catch (const std::exception& e) {
            FAIL() << "Failed to create {{ module.name | pascal_case }} instance: " << e.what();
        }
    }

    void TearDown() override {
        /* This method is called after each test */
        instance_.reset();
    }

    std::unique_ptr<{{ module.name | pascal_case }}> instance_;
};

/* ========================================================================== */
/* Construction and Destruction Tests                                        */
/* ========================================================================== */

TEST_F({{ module.name | pascal_case }}Test, ConstructorSuccess) {
    EXPECT_TRUE(instance_->is_valid());
    EXPECT_TRUE(instance_->get_last_error().empty());
}

TEST_F({{ module.name | pascal_case }}Test, MoveConstructor) {
    ASSERT_TRUE(instance_->is_valid());
    
    {{ module.name | pascal_case }} moved_instance(std::move(*instance_));
    EXPECT_TRUE(moved_instance.is_valid());
    EXPECT_FALSE(instance_->is_valid()); // Original should be invalid after move
}

TEST_F({{ module.name | pascal_case }}Test, MoveAssignment) {
    ASSERT_TRUE(instance_->is_valid());
    
    {{ module.name | pascal_case }} other_instance;
    EXPECT_TRUE(other_instance.is_valid());
    
    other_instance = std::move(*instance_);
    EXPECT_TRUE(other_instance.is_valid());
    EXPECT_FALSE(instance_->is_valid()); // Original should be invalid after move
}

/* ========================================================================== */
/* Basic Functionality Tests                                                 */
/* ========================================================================== */

TEST_F({{ module.name | pascal_case }}Test, IsValidAfterConstruction) {
    EXPECT_TRUE(instance_->is_valid());
}

TEST_F({{ module.name | pascal_case }}Test, GetLastErrorInitiallyEmpty) {
    EXPECT_TRUE(instance_->get_last_error().empty());
}

/* ========================================================================== */
/* Function-Specific Tests                                                   */
/* ========================================================================== */

{% if module.functions %}
{% for func in module.functions %}
{% if not func.is_static %}
TEST_F({{ module.name | pascal_case }}Test, {{ func.name | pascal_case }}Basic) {
    ASSERT_TRUE(instance_->is_valid());
    
    {% if func['parameters'] %}
    /* TODO: Initialize test parameters */
    {% for param in func['parameters'] %}
    {% if param.type == 'int' or param.type == 'size_t' %}
    {{ param.type }} {{ param.name | snake_case }} = 0;
    {% elif param.type == 'std::string' or param.type == 'const std::string&' %}
    std::string {{ param.name | snake_case }} = "test";
    {% elif param.type == 'bool' %}
    bool {{ param.name | snake_case }} = true;
    {% elif param.type == 'double' or param.type == 'float' %}
    {{ param.type }} {{ param.name | snake_case }} = 0.0;
    {% else %}
    {{ param.type }} {{ param.name | snake_case }}{};
    {% endif %}
    {% endfor %}
    {% endif %}
    
    {% if func.return_type == 'void' %}
    EXPECT_NO_THROW({
        instance_->{{ func.name | snake_case }}({% for param in func['parameters'] %}{{ param.name | snake_case }}{% if not loop.last %}, {% endif %}{% endfor %});
    });
    {% else %}
    {{ func.return_type }} result;
    EXPECT_NO_THROW({
        result = instance_->{{ func.name | snake_case }}({% for param in func['parameters'] %}{{ param.name | snake_case }}{% if not loop.last %}, {% endif %}{% endfor %});
    });
    
    /* TODO: Add appropriate assertions for return value */
    {% if func.return_type == 'bool' %}
    EXPECT_TRUE(result || !result); // Just check it's a valid bool
    {% elif func.return_type == 'int' or func.return_type == 'size_t' %}
    EXPECT_GE(result, 0); // Assuming non-negative return values
    {% elif func.return_type == 'std::string' %}
    EXPECT_FALSE(result.empty()); // Assuming non-empty strings
    {% endif %}
    {% endif %}
    
    EXPECT_TRUE(instance_->is_valid());
}

{% if func['parameters'] %}
TEST_F({{ module.name | pascal_case }}Test, {{ func.name | pascal_case }}InvalidParameters) {
    ASSERT_TRUE(instance_->is_valid());
    
    {% for param in func['parameters'] %}
    {% if param.type == 'std::string' or param.type == 'const std::string&' %}
    /* Test with empty string parameter */
    {% if func.return_type == 'void' %}
    EXPECT_THROW({
        instance_->{{ func.name | snake_case }}({% for p in func['parameters'] %}{% if p.name == param.name %}""{% else %}{% if p.type == 'int' or p.type == 'size_t' %}0{% elif p.type == 'std::string' or p.type == 'const std::string&' %}"test"{% elif p.type == 'bool' %}true{% else %}{}{% endif %}{% endif %}{% if not loop.last %}, {% endif %}{% endfor %});
    }, {{ module.name | pascal_case }}InvalidArgumentException);
    {% else %}
    EXPECT_THROW({
        auto result = instance_->{{ func.name | snake_case }}({% for p in func['parameters'] %}{% if p.name == param.name %}""{% else %}{% if p.type == 'int' or p.type == 'size_t' %}0{% elif p.type == 'std::string' or p.type == 'const std::string&' %}"test"{% elif p.type == 'bool' %}true{% else %}{}{% endif %}{% endif %}{% if not loop.last %}, {% endif %}{% endfor %});
        (void)result;
    }, {{ module.name | pascal_case }}InvalidArgumentException);
    {% endif %}
    {% endif %}
    {% endfor %}
}
{% endif %}

TEST_F({{ module.name | pascal_case }}Test, {{ func.name | pascal_case }}OnInvalidInstance) {
    /* Test calling method on invalid instance */
    instance_.reset(); // Make instance invalid
    instance_ = std::make_unique<{{ module.name | pascal_case }}>();
    
    /* Simulate invalid state */
    {{ module.name | pascal_case }} invalid_instance(std::move(*instance_));
    *instance_ = std::move(invalid_instance); // Now instance_ should be invalid
    
    {% if func['parameters'] %}
    {% for param in func['parameters'] %}
    {% if param.type == 'int' or param.type == 'size_t' %}
    {{ param.type }} {{ param.name | snake_case }} = 0;
    {% elif param.type == 'std::string' or param.type == 'const std::string&' %}
    std::string {{ param.name | snake_case }} = "test";
    {% elif param.type == 'bool' %}
    bool {{ param.name | snake_case }} = true;
    {% else %}
    {{ param.type }} {{ param.name | snake_case }}{};
    {% endif %}
    {% endfor %}
    {% endif %}
    
    EXPECT_THROW({
        {% if func.return_type == 'void' %}
        instance_->{{ func.name | snake_case }}({% for param in func['parameters'] %}{{ param.name | snake_case }}{% if not loop.last %}, {% endif %}{% endfor %});
        {% else %}
        auto result = instance_->{{ func.name | snake_case }}({% for param in func['parameters'] %}{{ param.name | snake_case }}{% if not loop.last %}, {% endif %}{% endfor %});
        (void)result;
        {% endif %}
    }, {{ module.name | pascal_case }}RuntimeException);
}

{% endif %}
{% endfor %}
{% endif %}

/* ========================================================================== */
/* Exception Tests                                                           */
/* ========================================================================== */

TEST({{ module.name | pascal_case }}ExceptionTest, BaseExceptionMessage) {
    const std::string message = "Test exception message";
    {{ module.name | pascal_case }}Exception ex(message);
    EXPECT_EQ(ex.what(), message);
}

TEST({{ module.name | pascal_case }}ExceptionTest, InvalidArgumentExceptionMessage) {
    const std::string message = "invalid parameter";
    {{ module.name | pascal_case }}InvalidArgumentException ex(message);
    std::string expected = "Invalid argument: " + message;
    EXPECT_EQ(ex.what(), expected);
}

TEST({{ module.name | pascal_case }}ExceptionTest, RuntimeExceptionMessage) {
    const std::string message = "runtime failure";
    {{ module.name | pascal_case }}RuntimeException ex(message);
    std::string expected = "Runtime error: " + message;
    EXPECT_EQ(ex.what(), expected);
}

/* ========================================================================== */
/* Free Function Tests                                                       */
/* ========================================================================== */

TEST({{ module.name | pascal_case }}FreeFunctionTest, GetVersion) {
    std::string version = get_version();
    EXPECT_FALSE(version.empty());
    EXPECT_EQ(version, "{{ config.version }}");
}

TEST({{ module.name | pascal_case }}FreeFunctionTest, GetBuildInfo) {
    std::string build_info = get_build_info();
    EXPECT_FALSE(build_info.empty());
    EXPECT_NE(build_info.find("{{ config.name }}"), std::string::npos);
    EXPECT_NE(build_info.find("{{ config.version }}"), std::string::npos);
}

/* ========================================================================== */
/* Enum Tests                                                                */
/* ========================================================================== */

{% if module.enums %}
{% for enum in module.enums %}
TEST({{ module.name | pascal_case }}EnumTest, {{ enum.name | pascal_case }}ToString) {
    {% for enum_value in enum['values'] %}
    std::string str = to_string({{ enum.name | pascal_case }}::{{ enum_value.name | pascal_case }});
    EXPECT_FALSE(str.empty());
    EXPECT_EQ(str, "{{ enum_value.name | pascal_case }}");
    {% endfor %}
}

{% endfor %}
{% endif %}

/* ========================================================================== */
/* Structure Tests                                                           */
/* ========================================================================== */

{% if module.structures %}
{% for struct in module.structures %}
TEST({{ module.name | pascal_case }}StructTest, {{ struct.name | pascal_case }}DefaultConstruction) {
    {{ struct.name | pascal_case }} instance;
    /* TODO: Add specific assertions for default-constructed instance */
    (void)instance; // Suppress unused variable warning
}

TEST({{ module.name | pascal_case }}StructTest, {{ struct.name | pascal_case }}EqualityOperators) {
    {{ struct.name | pascal_case }} instance1;
    {{ struct.name | pascal_case }} instance2;
    
    EXPECT_TRUE(instance1 == instance2);
    EXPECT_FALSE(instance1 != instance2);
    
    /* TODO: Modify one instance and test inequality */
}

TEST({{ module.name | pascal_case }}StructTest, {{ struct.name | pascal_case }}CopySemantics) {
    {{ struct.name | pascal_case }} original;
    
    /* Test copy constructor */
    {{ struct.name | pascal_case }} copied(original);
    EXPECT_TRUE(original == copied);
    
    /* Test copy assignment */
    {{ struct.name | pascal_case }} assigned;
    assigned = original;
    EXPECT_TRUE(original == assigned);
}

TEST({{ module.name | pascal_case }}StructTest, {{ struct.name | pascal_case }}MoveSemantics) {
    {{ struct.name | pascal_case }} original;
    {{ struct.name | pascal_case }} backup = original;
    
    /* Test move constructor */
    {{ struct.name | pascal_case }} moved(std::move(original));
    EXPECT_TRUE(backup == moved);
    
    /* Test move assignment */
    {{ struct.name | pascal_case }} move_assigned;
    move_assigned = std::move(moved);
    EXPECT_TRUE(backup == move_assigned);
}

{% endfor %}
{% endif %}

/* ========================================================================== */
/* Performance Tests                                                         */
/* ========================================================================== */

TEST({{ module.name | pascal_case }}PerformanceTest, MultipleInstantiations) {
    const size_t instance_count = 1000;
    std::vector<std::unique_ptr<{{ module.name | pascal_case }}>> instances;
    
    instances.reserve(instance_count);
    
    EXPECT_NO_THROW({
        for (size_t i = 0; i < instance_count; ++i) {
            instances.emplace_back(std::make_unique<{{ module.name | pascal_case }}>());
            EXPECT_TRUE(instances.back()->is_valid());
        }
    });
    
    /* Cleanup is automatic via RAII */
}

/* ========================================================================== */
/* Thread Safety Tests (Basic)                                              */
/* ========================================================================== */

TEST({{ module.name | pascal_case }}ThreadSafetyTest, ConcurrentInstantiation) {
    const size_t thread_count = 4;
    const size_t instances_per_thread = 100;
    
    std::vector<std::thread> threads;
    std::atomic<size_t> success_count{0};
    
    for (size_t t = 0; t < thread_count; ++t) {
        threads.emplace_back([&success_count, instances_per_thread]() {
            for (size_t i = 0; i < instances_per_thread; ++i) {
                try {
                    {{ module.name | pascal_case }} instance;
                    if (instance.is_valid()) {
                        success_count.fetch_add(1);
                    }
                } catch (const std::exception&) {
                    /* Count as failure */
                }
            }
        });
    }
    
    for (auto& thread : threads) {
        thread.join();
    }
    
    EXPECT_EQ(success_count.load(), thread_count * instances_per_thread);
}

/* ========================================================================== */
/* Main Function                                                             */
/* ========================================================================== */

int main(int argc, char** argv) {
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}
