/**
 * @file {{ module.name }}.h
 * @brief {{ module.description or 'Module: ' + module.name }}
 * @author {{ config.author or 'Generated by C/C++ Code Generator' }}
 * @version {{ config.version }}
 * @date {{ config.generated_at[:10] }}
 * 
 * {{ config.description or 'Auto-generated C++ library module' }}
 * 
{% if config.license %}
 * @license {{ config.license }}
{% endif %}
 */

#ifndef {{ module.name | header_guard }}
#define {{ module.name | header_guard }}

#include <cstddef>
#include <cstdint>
#include <memory>
#include <string>
#include <vector>
#include <stdexcept>

{% if config.cpp_standard in ['cpp17', 'cpp20', 'cpp23'] %}
#include <optional>
#include <string_view>
{% endif %}

{% if config.namespace %}
namespace {{ config.namespace }} {
{% endif %}

/**
 * @defgroup {{ module.name }} {{ module.name | title }} Module
 * @brief {{ module.description or 'Module: ' + module.name }}
 * @{
 */

/* ========================================================================== */
/* Constants and Macros                                                       */
/* ========================================================================== */

{% if module.constants %}
{% for constant in module.constants %}
/**
 * @brief {{ constant.description or 'Constant: ' + constant.name }}
 */
constexpr {{ constant.type }} {{ constant.name }} = {{ constant.value }};

{% endfor %}
{% endif %}

/* ========================================================================== */
/* Exception Classes                                                          */
/* ========================================================================== */

/**
 * @brief Base exception class for {{ module.name }} module
 */
class {{ module.name | pascal_case }}Exception : public std::runtime_error {
public:
    explicit {{ module.name | pascal_case }}Exception(const std::string& message)
        : std::runtime_error(message) {}
};

/**
 * @brief Invalid argument exception
 */
class {{ module.name | pascal_case }}InvalidArgumentException : public {{ module.name | pascal_case }}Exception {
public:
    explicit {{ module.name | pascal_case }}InvalidArgumentException(const std::string& message)
        : {{ module.name | pascal_case }}Exception("Invalid argument: " + message) {}
};

/**
 * @brief Runtime error exception
 */
class {{ module.name | pascal_case }}RuntimeException : public {{ module.name | pascal_case }}Exception {
public:
    explicit {{ module.name | pascal_case }}RuntimeException(const std::string& message)
        : {{ module.name | pascal_case }}Exception("Runtime error: " + message) {}
};

/* ========================================================================== */
/* Type Definitions                                                           */
/* ========================================================================== */

{% if module.enums %}
{% for enum in module.enums %}
/**
 * @brief {{ enum.description or 'Enumeration: ' + enum.name }}
 */
enum class {{ enum.name | pascal_case }} : {{ enum.type or 'int' }} {
{% for value in enum['values'] %}
    {{ value.name | pascal_case }}{% if value.value is defined %} = {{ value.value }}{% endif %},  ///< {{ value.description or value.name }}
{% endfor %}
};

/**
 * @brief Convert {{ enum.name | pascal_case }} to string
 * @param value Enum value
 * @return std::string String representation
 */
std::string to_string({{ enum.name | pascal_case }} value);

{% endfor %}
{% endif %}

{% if module.structures %}
{% for struct in module.structures %}
/**
 * @brief {{ struct.description or 'Structure: ' + struct.name }}
 */
{% if struct.is_packed %}
#pragma pack(push, 1)
{% endif %}
struct {{ struct.name | pascal_case }} {
{% for field in struct['fields'] %}
    {{ field.type }} {{ field.name | snake_case }}{% if field.array_size %}[{{ field.array_size }}]{% endif %};  ///< {{ field.description or field.name }}
{% endfor %}

    /**
     * @brief Default constructor
     */
    {{ struct.name | pascal_case }}() = default;

    /**
     * @brief Destructor
     */
    ~{{ struct.name | pascal_case }}() = default;

    /**
     * @brief Copy constructor
     */
    {{ struct.name | pascal_case }}(const {{ struct.name | pascal_case }}&) = default;

    /**
     * @brief Copy assignment operator
     */
    {{ struct.name | pascal_case }}& operator=(const {{ struct.name | pascal_case }}&) = default;

    /**
     * @brief Move constructor
     */
    {{ struct.name | pascal_case }}({{ struct.name | pascal_case }}&&) noexcept = default;

    /**
     * @brief Move assignment operator
     */
    {{ struct.name | pascal_case }}& operator=({{ struct.name | pascal_case }}&&) noexcept = default;

    /**
     * @brief Equality comparison operator
     */
    bool operator==(const {{ struct.name | pascal_case }}& other) const noexcept;

    /**
     * @brief Inequality comparison operator
     */
    bool operator!=(const {{ struct.name | pascal_case }}& other) const noexcept;
};
{% if struct.is_packed %}
#pragma pack(pop)
{% endif %}

{% endfor %}
{% endif %}

/* ========================================================================== */
/* Class Declarations                                                         */
/* ========================================================================== */

/**
 * @brief {{ module.name | pascal_case }} class
 * 
 * {{ module.description or 'Main class for ' + module.name + ' module' }}
 * 
 * This class provides a RAII wrapper around the {{ module.name }} functionality.
 * It ensures proper initialization and cleanup, and provides a type-safe
 * interface to the underlying functionality.
 * 
 * Example usage:
 * @code
 * try {
 *     {{ module.name | pascal_case }} instance;
 *     // Use instance...
 * } catch (const {{ module.name | pascal_case }}Exception& e) {
 *     std::cerr << "Error: " << e.what() << std::endl;
 * }
 * @endcode
 */
class {{ module.name | pascal_case }} {
public:
    /**
     * @brief Default constructor
     * @throws {{ module.name | pascal_case }}Exception on initialization failure
     */
    {{ module.name | pascal_case }}();

    /**
     * @brief Destructor
     */
    ~{{ module.name | pascal_case }}();

    /**
     * @brief Copy constructor (deleted for resource safety)
     */
    {{ module.name | pascal_case }}(const {{ module.name | pascal_case }}&) = delete;

    /**
     * @brief Copy assignment operator (deleted for resource safety)
     */
    {{ module.name | pascal_case }}& operator=(const {{ module.name | pascal_case }}&) = delete;

    /**
     * @brief Move constructor
     */
    {{ module.name | pascal_case }}({{ module.name | pascal_case }}&& other) noexcept;

    /**
     * @brief Move assignment operator
     */
    {{ module.name | pascal_case }}& operator=({{ module.name | pascal_case }}&& other) noexcept;

{% if module.functions %}
{% for func in module.functions %}
    /**
     * @brief {{ func.description or 'Function: ' + func.name }}
     * 
{% for param in func['parameters'] %}
     * @param {{ param.name | snake_case }} {{ param.description or param.name }}
{% endfor %}
     * @return {{ func.return_type }} {{ 'Function result' }}
     * @throws {{ module.name | pascal_case }}Exception on error
     * 
     * Example usage:
     * @code
     * {{ module.name | pascal_case }} instance;
     * auto result = instance.{{ func.name | snake_case }}({% for param in func['parameters'] %}{{ param.name | snake_case }}{% if not loop.last %}, {% endif %}{% endfor %});
     * @endcode
     */
    {% if func.is_static %}static {% endif %}{{ func.return_type }} {{ func.name | snake_case }}(
{% if func['parameters'] %}
{% for param in func['parameters'] %}
        {% if param.is_const %}const {% endif %}{{ param.type }}{% if param.is_pointer %}&{% endif %} {{ param.name | snake_case }}{% if param.default_value %} = {{ param.default_value }}{% endif %}{% if not loop.last %},{% endif %}
{% endfor %}
{% endif %}
    ){% if not func.is_static %} const{% endif %};

{% endfor %}
{% endif %}

    /**
     * @brief Check if the instance is valid
     * @return bool True if valid, false otherwise
     */
    bool is_valid() const noexcept;

    /**
     * @brief Get the last error message
     * @return std::string Error message
     */
    std::string get_last_error() const;

private:
    struct Impl;  ///< Forward declaration for PIMPL idiom
    std::unique_ptr<Impl> pimpl_;  ///< Private implementation pointer
};

/* ========================================================================== */
/* Free Function Declarations                                                */
/* ========================================================================== */

/**
 * @brief Get library version
 * @return std::string Version string
 */
std::string get_version();

/**
 * @brief Get library build information
 * @return std::string Build information
 */
std::string get_build_info();

/**
 * @}
 */

{% if config.namespace %}
} // namespace {{ config.namespace }}
{% endif %}

#endif /* {{ module.name | header_guard }} */
